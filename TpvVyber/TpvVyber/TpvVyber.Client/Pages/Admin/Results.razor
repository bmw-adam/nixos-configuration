@page "/admin/results"
@attribute [Authorize(Roles = "Admin")]
@using System.Text
@using System.IO
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components
@inject IAdminService AdminService
@inject PersistentComponentState ApplicationState
@inject IJSRuntime JS
@inject IUpdateService updateService
@implements IDisposable
@implements IClientUpdateHandler

<PageTitle>Výsledky</PageTitle>
<MudText aria-label="vysledky-header" Typo="Typo.h4">Výsledky</MudText>

<MudText aria-label="vysledky-header-konec" Typo="Typo.h6">Konec:</MudText>
<MudStack Row>
    <MudDatePicker aria-label="vysledky-konec-datum" Label="Datum" @bind-Date="LoggingEndTime"></MudDatePicker>
    <MudTimePicker aria-label="vysledky-konec-cas" Label="čas" @bind-Time="LoggingEndTimeSpan"></MudTimePicker>
    <MudButton aria-label="vysledky-konec-sumbit" OnClick="SubmitDateTime">Ok</MudButton>
</MudStack>
<div style="height: 20px;"></div>
<MudPaper Class="doc-section-component-container">
    @if (_series.Count > 0)
    {
        <MudChart ChartType="MudBlazor.ChartType.StackedBar" ChartSeries="@_series" @bind-SelectedIndex="_index"
            XAxisLabels="@_xAxisLabels" Width="100%" Height="auto" AxisChartOptions="_axisChartOptions"></MudChart>
    }
    else
    {
        <MudText Align="Align.Center" Class="pa-4">Načítám graf...</MudText>
    }
</MudPaper>
<MudText aria-label="vysledky-konec-caption" Typo="Typo.caption"><i>Kolik lidí si dalo kurz na kolikáté pořadí?</i></MudText>

<div style="height: 10px"></div>
<MudText aria-label="vysledky-vysledky-header" Typo="Typo.h4">Pořadí - Výsledky</MudText>
<MudTable aria-label="vysledky-vysledky-table" Items="@(Students ?? [])" Hover="true" Breakpoint="Breakpoint.Sm"
    Loading="@(StudentCourses == null || Students == null)" LoadingProgressColor="Color.Info">
    <HeaderContent>
        <MudTh aria-label="vysledky-vysledky-table-header-trida">Třída</MudTh>
        <MudTh aria-label="vysledky-vysledky-table-header-jmeno-zaka">Jméno žáka</MudTh>
        <MudTh aria-label="vysledky-vysledky-table-header-email">E-Mail</MudTh>
        <MudTh aria-label="vysledky-vysledky-table-header-nazev-kurzu">Název kurzu</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd aria-label="@($"vysledky-vysledky-table-values-{context.Email}-trida")" DataLabel="Třída">@GetClassName(context.Class)</MudTd>
        <MudTd aria-label="@($"vysledky-vysledky-table-values-{context.Email}-jmeno-zaka")" DataLabel="Jméno žáka">@context.Name</MudTd>
        <MudTd aria-label="@($"vysledky-vysledky-table-values-{context.Email}-email")" DataLabel="E-Mail">@context.Email</MudTd>
        <MudTd aria-label="@($"vysledky-vysledky-table-values-{context.Email}-vybrany-kurz")" DataLabel="Název kurzu">@GetCourseNameForStudent(context)</MudTd>
    </RowTemplate>
</MudTable>

<MudButton aria-label="vysledky-vysledky-export" StartIcon="@Icons.Material.Outlined.ImportExport" OnClick="ExportCsv" Variant="Variant.Filled"
    Color="Color.Primary" Disabled="@(Students == null)">
    Export CSV
</MudButton>

@code {
    private PersistingComponentStateSubscription? _subscription;
    [CascadingParameter]
    public bool ReThrowError { get; set; }

    private Dictionary<CourseCln, List<StudentCln>>? StudentCourses;
    private List<StudentCln>? Students { get; set; }
    private List<CourseCln>? Courses { get; set; }
    
    private DateTime? LoggingEndTime;
    private TimeSpan? LoggingEndTimeSpan;
    private LoggingEndingCln? loggingEndingCln;
    private EventHandler<TpvUpdateEventArgs>? _updateHandler;

    private int _index = -1;
    private AxisChartOptions _axisChartOptions = new AxisChartOptions() { XAxisLabelRotation = 90, MatchBoundsToSize = true};

    private List<ChartSeries> _series = new List<ChartSeries>();
    private string[] _xAxisLabels = { };

    protected override void OnInitialized()
    {
        _subscription = ApplicationState.RegisterOnPersisting(Persist);
        _ = AsyncLoad();
        _updateHandler = ((IClientUpdateHandler)this).FactoryUpdateHandler(
            [TableNames.Students, TableNames.Courses, TableNames.LoggingEndings, TableNames.OrderCourses],
            AsyncLoad
        );

        if (_updateHandler is not null)
        {
            updateService.RegisterFunction(_updateHandler);
        }

    }

    private async Task AsyncLoad(bool forceReload = false)
    {
        // 1. Start loading independent data streams in parallel
        var t1 = LoadStudentsAsync(forceReload);
        var t2 = LoadCoursesAsync(forceReload);
        var t3 = LoadLoggingEndAsync(forceReload);

        // Wait for basic data to arrive
        await Task.WhenAll(t1, t2, t3);

        // 2. Build the Dictionary
        // We do this AFTER courses are loaded so we can look up Course objects in memory
        // instead of calling the API N times.
        await LoadStudentCoursesDictionaryAsync(forceReload);

        // 3. Prepare Chart Data
        PrepareChartData();

        StateHasChanged();
    }

    private async Task LoadStudentsAsync(bool forceReload)
    {
        if (ApplicationState.TryTakeFromJson<List<StudentCln>>(nameof(Students), out var cached))
        {
            Students = cached;
        }
        if (Students == null || Students.Count == 0 || !ApplicationState.TryTakeFromJson<int>(nameof(Students), out var _) || forceReload)
        {
            Students = new List<StudentCln>();
            await foreach (var student in AdminService.GetAllStudentsAsync(ReThrowError, FillStudentExtended.Courses |
            FillStudentExtended.OrderCourses))
            {
                Students.Add(student);
            }
        }
    }

    private async Task LoadCoursesAsync(bool forceReload)
    {
        if (ApplicationState.TryTakeFromJson<List<CourseCln>>(nameof(Courses), out var cached))
        {
            Courses = cached;
        }
        if (Courses == null || Courses.Count == 0 || !ApplicationState.TryTakeFromJson<int>(nameof(Courses), out var _) || forceReload)
        {
            Courses = new List<CourseCln>();
            await foreach (var course in AdminService.GetAllCoursesAsync(ReThrowError, FillCourseExtended.OrderCourses |
            FillCourseExtended.Students))
            {
                Courses.Add(course);
            }
        }
    }

    private async Task LoadLoggingEndAsync(bool forceReload)
    {
        var loggingEnd = await AdminService.GetLoggingEndings(ReThrowError);
        if (loggingEnd?.TimeEnding != null)
        {
            LoggingEndTime = loggingEnd.TimeEnding.Date;
            LoggingEndTimeSpan = loggingEnd.TimeEnding - loggingEnd.TimeEnding.Date;
        }
        loggingEndingCln = loggingEnd;
    }

    private async Task LoadStudentCoursesDictionaryAsync(bool forceReload)
    {
        if (ApplicationState.TryTakeFromJson<Dictionary<CourseCln, List<StudentCln>>>(nameof(StudentCourses), out var cached) || forceReload)
        {
            StudentCourses = cached;
        }

        if (StudentCourses == null || StudentCourses.Count == 0 || !ApplicationState.TryTakeFromJson<int>(nameof(StudentCourses),
        out var _))
        {
            // Fetch the raw allocation (assuming Key is CourseId (int))
            // Note: Assuming ShowFillCourses returns Dictionary<int, IEnumerable<StudentCln>>
            var rawDict = await AdminService.ShowFillCourses(true, ReThrowError, FillCourseExtended.Students, null);

            StudentCourses = new Dictionary<CourseCln, List<StudentCln>>();

            if (Courses != null)
            {
                foreach (var pair in rawDict)
                {
                    // Optimization: Find the course object in the already loaded list
                    // This avoids calling GetCourseByIdAsync inside a loop (N+1 problem)
                    var courseObj = Courses.FirstOrDefault(c => c.Id == pair.Key);

                    if (courseObj != null)
                    {
                        StudentCourses.Add(courseObj, pair.Value.ToList());
                    }
                }
            }
        }
    }

    private void PrepareChartData()
    {
        if (StudentCourses == null || Students == null || Courses == null) return;

        _xAxisLabels = Courses.Select(e => e.Name).Order().ToArray();// (StudentCourses.Select(e => e.Key.Name).ToArray() ?? []).Order().ToArray();
        _series.Clear();

        var distinctOrders = Students
        .SelectMany(e => e.Extended?.OrderCourses ?? [])
        .Where(r => r is not null)
        .Select(r => r.Order)
        .Distinct()
        .OrderBy(o => o);

        foreach (var order in distinctOrders)
        {
            _series.Add(new ChartSeries()
            {
                Name = $"Pořadí {order}",
                Data = _xAxisLabels
            .Select(label => Courses.FirstOrDefault(s => s.Name == label))
            .Select(course => course?.Extended?.OrderCourses?.Count(d => d.Order == order) ?? 0)
            .Select(count => (double)count)
            .ToArray()
            });
        }
    }

    public void Dispose()
    {
        _subscription?.Dispose();
        if (_updateHandler is not null)
        {
            updateService.UnregisterFunction(_updateHandler);
        }
    }

    private Task Persist()
    {
        if (StudentCourses is not null)
            ApplicationState.PersistAsJson(nameof(StudentCourses), StudentCourses);

        if (Students is not null)
            ApplicationState.PersistAsJson(nameof(Students), Students);

        if (Courses is not null)
            ApplicationState.PersistAsJson(nameof(Courses), Courses);

        return Task.CompletedTask;
    }

    private string GetClassName(string classRoles)
    {
        if (string.IsNullOrEmpty(classRoles)) return "";
        var roles = classRoles.Split(";");
        return roles.OrderByDescending(e => ClassExtensions.CalculateClaimStrenght(e)).FirstOrDefault() ?? "";
    }

    async Task SubmitDateTime()
    {
        if (LoggingEndTimeSpan == null || LoggingEndTime == null || loggingEndingCln == null)
        {
            return;
        }
        loggingEndingCln.TimeEnding = LoggingEndTime.Value.Add(LoggingEndTimeSpan.Value);
        await AdminService.UpdateLoggingEnding(loggingEndingCln, ReThrowError);
        @* await AsyncLoad(); // Reloads data to confirm update *@
    }

    private string GetCourseNameForStudent(StudentCln student)
    {
        if (StudentCourses == null) return "";

        // Find which course list contains this student
        return StudentCourses
        .FirstOrDefault(e => e.Value.Any(s => s.Id == student.Id))
        .Key?.Name ?? "";
    }

    private async Task ExportCsv()
    {
        if (Students == null) return;

        var separator = ";";
        var sb = new StringBuilder();

        sb.AppendLine($"Třída{separator}Jméno žáka{separator}E-Mail{separator}Název kurzu");

        foreach (var student in Students)
        {
            var className = GetClassName(student.Class);
            var studentName = student.Name;
            var email = student.Email;
            var courseName = GetCourseNameForStudent(student);

            var line =
            $"{ClassExtensions.EscapeCsv(className)}{separator}{ClassExtensions.EscapeCsv(studentName)}{separator}{ClassExtensions.EscapeCsv(email)}{separator}{ClassExtensions.EscapeCsv(courseName)}";
            sb.AppendLine(line);
        }

        using var stream = new MemoryStream();
        using var writer = new StreamWriter(stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));
        await writer.WriteAsync(sb.ToString());
        await writer.FlushAsync();
        stream.Position = 0;

        using var streamRef = new DotNetStreamReference(stream);
        await JS.InvokeVoidAsync("downloadFileFromStream", "Vysledky.csv", streamRef);
    }

    void IClientUpdateHandler.StateHasChanged()
    {
        StateHasChanged();
    }

    Task IClientUpdateHandler.InvokeAsync(Func<Task> work)
    {
        return InvokeAsync(work);
    }
}