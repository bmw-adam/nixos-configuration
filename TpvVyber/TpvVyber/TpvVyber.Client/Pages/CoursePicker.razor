@page "/counter"
@using System.Threading.Tasks
@using System.Runtime.InteropServices
@attribute [Authorize]
@inject ISelectService SelectService
@inject ISnackbar snackbar
@inject NavigationManager navigationManager

<PageTitle>Counter</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Counter</MudText>

@if (SortableCourses != null)
{
    <SortableList Style="width: 100%" Handle=".drag-handle" TItem="CourseCln" @ref="SortableListRef" Data="SortableCourses"
        Context="item" AllowSorting OnUpdate="@OnListUpdate">
        <ItemTemplate>
            <MudStack StretchItems="StretchItems.End" Row>
                <MudIconButton Icon="@Icons.Material.Filled.DragIndicator" class="drag-handle"></MudIconButton>
                <MudBadge Style="width: 100%" Content="@item.Extended?.Availability?.GetDescription()" Color="Color.Primary" Overlap="true"
                    Class="mx-6 my-4">
                    <MudButton Style="width: 100%" OnClick="@(() => navigationManager.NavigateTo($"/course_info/{item.Id}"))"
                        EndIcon="@Icons.Material.Filled.Info">
                        @item.Name
                    </MudButton>
                </MudBadge>
            </MudStack>
        </ItemTemplate>
    </SortableList>
}
else
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-7" />
}

<MudStack Justify="Justify.FlexEnd" Row Spacing="5">
    <MudButton OnClick="InitialLoadSort" Color="Color.Secondary" Variant="Variant.Outlined"
        StartIcon="@Icons.Material.Filled.Cancel">Zrušit
    </MudButton>
    <MudButton OnClick="AsyncUpdate" Color="Color.Info" Variant="Variant.Outlined"
        StartIcon="@Icons.Material.Filled.Save">Ok</MudButton>
</MudStack>

@code {
    SortableList<CourseCln>? SortableListRef;
    List<CourseCln>? SortableCourses = null;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _ = InitialLoadSort();
    }

    private async Task InitialLoadSort()
    {
        var dict = await SelectService.GetSortedCoursesAsync(FillCourseExtended.Availability);
        var lst = dict?.OrderBy(d => d.Key)?.Select(r => r.Value) ?? [];


        if (dict == null || lst == null)
        {
            snackbar.Add("Nepodařilo se mi získat data.");
            return;
        }

        SortableCourses = lst.ToList();

        StateHasChanged();
    }

    private void OnListUpdate(SortableListEventArgs args)
    {
        if (SortableCourses == null)
        {
            snackbar.Add("Nenačetl jsem data", Severity.Error);
            return;
        }

        var itemToMove = SortableCourses[args.OldIndex];
        SortableCourses.RemoveAt(args.OldIndex);

        if (args.NewIndex < SortableCourses.Count)
            SortableCourses.Insert(args.NewIndex, itemToMove);
        else
            SortableCourses.Add(itemToMove);
    }

    private async Task AsyncUpdate()
    {
        if (SortableCourses == null)
        {
            snackbar.Add("Nenačetl jsem data", Severity.Error);
            return;
        }

        await SelectService.UpdateOrderAsync(
        SortableCourses
        .Select((course, index) => new { index, course })
        .ToDictionary(x => x.index, x => x.course)
        );
        await InitialLoadSort();
    }

    private Color AvailabilityBadge(Availability availability)
    {
        switch (availability)
        {
            case Availability.Free:
                return Color.Success;
            case Availability.Rullette:
                return Color.Warning;
            case Availability.Occupied:
                return Color.Error;
            default:
                return Color.Default;
        }
    }
}