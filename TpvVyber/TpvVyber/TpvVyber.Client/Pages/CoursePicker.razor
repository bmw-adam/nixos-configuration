@page "/tpv_picker"
@attribute [Authorize]
@inject ISelectService SelectService
@inject NotificationService notificationService
@inject NavigationManager navigationManager
@inject PersistentComponentState ApplicationState
@implements IDisposable
@inject IJSRuntime JS
@inject IUpdateService updateService
@implements IClientUpdateHandler

<PageTitle>Výběr TPV</PageTitle>

<MudText Typo="Typo.h5" GutterBottom="true">Seřadit kurzy</MudText>

<AuthorizeView>
    <Authorized>
        @if((SortableCourses ?? []).Where(e => ((e.Extended?.OrderCourses?.Select(y => y.StudentId.ToString())) ?? []).Contains(context.User.Claims.FirstOrDefault(e => e.Type == "ID_CLAIM")?.Value ?? "-1")).Count() == 0)
        {
            <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">Ještě nejsi přihlášen na žádný kurz</MudAlert>
        }
    </Authorized>
    <NotAuthorized>
        <p>Uživatel není přihlášen.</p>
    </NotAuthorized>
</AuthorizeView>
<MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">Klikni na OK pro uložení výběru</MudAlert>


@if (SortableCourses != null)
{
    <SortableList EmptyText="Nejsou k dispozici žádné kurzy" aria-label="SortableList-CoursePicker" Style="width: 100%"
        Handle=".drag-handle" TItem="CourseCln" @ref="SortableListRef" Data="SortableCourses" Context="item" AllowSorting
        OnUpdate="@OnListUpdate">
        <ItemTemplate>
            <MudStack aria-label="@($"SortableList-CoursePicker-{item.Name}")" StretchItems="StretchItems.Middle" Row>
                <MudIconButton aria-label="@($"SortableList-CoursePicker-{item.Name}-drag")"
                    Icon="@Icons.Material.Outlined.DragIndicator" class="drag-handle"></MudIconButton>
                <MudButton aria-label="@($"SortableList-CoursePicker-{item.Name}-btn")"
                    OnClick="@(() => navigationManager.NavigateTo($"/course_info/{item.Id}"))"
                    EndIcon="@Icons.Material.Outlined.Info">
                    <MudLink aria-label="@($"SortableList-CoursePicker-{item.Name}-link")"
                        Href="@($"/course_info/{item.Id}")">@item.Name</MudLink>
                </MudButton>
                <MudTooltip aria-label="@($"SortableList-CoursePicker-{item.Name}-tooltip")"
                    Text="@item.Extended?.Availability?.GetDescription()">
                    <MudChip aria-label="@($"SortableList-CoursePicker-{item.Name}-avail")" T="string"
                        Variant="Variant.Outlined" Color="AvailabilityBadge(item.Extended?.Availability)">
                        @item.Extended?.Availability?.GetTooltip()</MudChip>
                </MudTooltip>
            </MudStack>
        </ItemTemplate>
    </SortableList>
}
else
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-7" />
}

<MudStack Justify="Justify.FlexEnd" Row Spacing="5">
    <MudButton aria-label="cancelBtn" OnClick="async () => await InitialLoadSort()" Color="Color.Secondary"
        Variant="Variant.Outlined" StartIcon="@Icons.Material.Outlined.Cancel">Zrušit
    </MudButton>
    <MudButton aria-label="okBtn" OnClick="AsyncUpdate" Color="Color.Info" Variant="Variant.Outlined"
        StartIcon="@Icons.Material.Outlined.Save">Ok</MudButton>
</MudStack>

@code {
    SortableList<CourseCln>? SortableListRef;
    List<CourseCln>? SortableCourses = null;
    private PersistingComponentStateSubscription? _subscription;
    [CascadingParameter]
    public bool ReThrowError { get; set; }
    private EventHandler<TpvUpdateEventArgs>? _updateHandler;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _subscription = ApplicationState.RegisterOnPersisting(Persist);

        _ = InitialLoadSort(true);
        _updateHandler = ((IClientUpdateHandler)this).FactoryUpdateHandler(
        [TableNames.Students, TableNames.OrderCourses, TableNames.Courses],
        InitialLoadSort
        );
        if (_updateHandler is not null)
        {
            updateService.RegisterFunction(_updateHandler);
        }
    }

    private async Task<List<CourseCln>?> ApiCallCourses()
    {
        var dict = await SelectService.GetSortedCoursesAsync(ReThrowError, FillCourseExtended.Availability | FillCourseExtended.OrderCourses);
        var lst = dict?.OrderBy(d => d.Key)?.Select(r => r.Value) ?? [];

        if (dict == null || lst == null)
        {
            notificationService.Notify("Nepodařilo se mi získat data.", Severity.Error);
            return null;
        }
        return lst?.ToList();
    }

    private async Task InitialLoadSort(bool forceReload = false)
    {
        if (forceReload)
        {
            SortableCourses = await ApiCallCourses();
        }
        else
        {
            SortableCourses = ApplicationState.TryTakeFromJson<IEnumerable<CourseCln>>(nameof(SortableCourses), out var cached)
            ? cached?.ToList()
            : (await ApiCallCourses());
        }

        if (ReThrowError)
        {
            _ = InvokeAsync(async () =>
            {
                StateHasChanged();
                await Task.Delay(1);
            });
        }
        else
        {
#pragma warning disable CS1998
            _ = InvokeAsync(async () => StateHasChanged());
#pragma warning restore CS1998
        }
    }

    private void OnListUpdate(SortableListEventArgs args)
    {
        if (SortableCourses == null)
        {
            notificationService.Notify("Nenačetl jsem data", Severity.Error);
            return;
        }

        var itemToMove = SortableCourses[args.OldIndex];
        SortableCourses.RemoveAt(args.OldIndex);

        if (args.NewIndex < SortableCourses.Count)
            SortableCourses.Insert(args.NewIndex, itemToMove);
        else
            SortableCourses.Add(itemToMove);
    }

    private async Task AsyncUpdate()
    {
        if (SortableCourses == null)
        {
            notificationService.Notify("Nenačetl jsem data", Severity.Error);
            return;
        }

        await SelectService.UpdateOrderAsync(
        SortableCourses
        .Select((course, index) => new { index, course })
        .ToDictionary(x => x.index, x => x.course)
        , ReThrowError
        );
        await InitialLoadSort();
    }

    private Color AvailabilityBadge(Availability? availability)
    {
        switch (availability)
        {
            case Availability.Free:
                return Color.Success;
            case Availability.Rullette:
                return Color.Warning;
            case Availability.Occupied:
                return Color.Error;
            case Availability.NotHappening:
                return Color.Info;
            default:
                return Color.Default;
        }
    }

    private Task Persist()
    {
        if (SortableCourses is not null)
            ApplicationState.PersistAsJson(nameof(SortableCourses), SortableCourses);

        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _subscription?.Dispose();
        if (_updateHandler is not null)
        {
            updateService.UnregisterFunction(_updateHandler);
        }
    }

    void IClientUpdateHandler.StateHasChanged()
    {
        StateHasChanged();
    }

    Task IClientUpdateHandler.InvokeAsync(Func<Task> work)
    {
        return InvokeAsync(work);
    }
}